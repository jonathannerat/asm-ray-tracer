\section{Ray Tracing} \label{sec:ray-tracing}

El \textit{Ray Tracing} es un algoritmo de renderizado en el que una imagen se
crea identificando los objetos que contribuyen a cada pixel (\textit{image-order
rendering}). Dada una escena con objetos tridimensionales, se puede obtener una
imagen de la misma lanzando rayos desde un origen (cámara) hacia una ventana, y
trazando la trayectoria de los mismos para ver sobre que objetos / materiales
incidió (Figura \ref{fig:rt-camera-window-scene}).

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{imgs/rt-camera-window-scene.png}
    \caption{Cámara lanzando rayos por una ventana hacia una escena}
    \label{fig:rt-camera-window-scene}
\end{figure}

En esta situación, la imagen final es el resultado de muchas variables:

\begin{itemize}
    \item Cámara: posición, dirección, inclinación, apertura de la lente,
        distancia de foco.
    \item Objetos: ubicación, tamaños, formas, etc.
    \item Materiales (de cada objeto): tipos (lambertiano, metálico, etc),
    color, reflexión, refracción, etc.
    \item Archivo de salida: Dimensiones, \textit{spp}, \textit{max depth}.
\end{itemize}

A continuación explicaremos como cada uno influye en la imagen final.

\subsection{Cámara} \label{ssec:rt-camera}

Como ya se mencionó, el origen de los rayos estará dado por la cámara. No
solamente por la posición de la misma, sino también por la apertura de la lente
y la distancia de foco.

Para poder controlar el ``nivel de enfoque'' de la imagen, la implementación
simula la lente de la cámara usando como verdadero origen de los rayos a un
disco. La apertura es el diámetro de la lente, y la distancia de foco
es la distancia entre el disco y el plano de foco.

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{imgs/rt-camera-plano-foco.png}
    \caption{Lente y plano de foco}
    \label{fig:rt-camera-plano-foco}
\end{figure}

Los rayos se lanzarán desde un punto aleatorio de la lente, hacia distintos
puntos en el plano de foco (dependiendo del pixel que se este calculando).
Mientras más chico sea el diámetro de la lente, y más cerca esté el plano de
foco del objetivo, más nítida será la imagen. Por el contrario, si la lente es
muy grande, o el plano de foco se encuentra lejos del objetivo, la imagen se
verá más borrosa.

\subsection{Objetos}

Los objetos son cuerpos del espacio tridimensional que pueden colisionar con los
rayos y en consecuencia, modificar la trayectoria de los mismos y finalmente  la
imagen. Dependiendo del material de su superficie, estos pueden reflejar o
refractar los rayos, y cambiar el color de cada pixel. En este trabajo se
implementaron 4 objetos

\begin{itemize}
    \item Esferas
    \item Planos
    \item Cubos
    \item Triángulos
\end{itemize}

Cada objeto es definido por una función que indica si un rayo colisiona o no con
el mismo (\texttt{hit}). Además, esta función retorna (en caso de que haya
colisión) detalles de como se dio la misma: el punto de intersección, la normal
de la superficie en ese punto, el material del objeto, etc.

Por ejemplo, la función \texttt{hit} de un plano devuelve verdadero si el rayo
\textbf{no} es paralelo al plano (suponiendo que el rayo y el plano no se
superponen). Por otro lado, para una esfera la función devuelve verdadero si el
rayo ``pasa'' lo suficientemente cerca del origen (radio de la esfera).

Formalmente, representaremos a un rayo como un par
$\left\langle P, D \right\rangle$, donde $P$ es el punto de origen y $D$ es la
dirección. De esta forma, podemos describir cada punto del rayo $R(t) = P + tD$.
La función \texttt{hit} de un objeto (e.g. \textsc{\texttt{ObjectHit}}) recibirá
como parámetros:

\begin{itemize}
    \item El objeto, para saber sus coordenadas y dimensiones
    \item El rayo
    \item $t_{min}$ y $t_{max}$: el rango de valores de $t$ (del rayo) a
        considerar. Por ejemplo, no consideramos colisiones con $t < 0$ porque
        se encuentran detrás de la cámara y no aparecen en la imagen final
\end{itemize}

Y retornará dos valores:

\begin{itemize}
    \item Un booleano, para indicar si hay intersección o no
    \item Un diccionario con los datos de la colisión, si corresponde
\end{itemize}

Como vimos, la implementación de cada función \texttt{hit} puede ser muy
diferente dependiendo de la forma y las propiedades de cada objeto, así que
exploraremos cada uno por separado.

\subsubsection{Plano}

Un plano está dado por un origen $O$ y una normal $N$. Para decidir si un rayo
$R(t) = P + tD$ interseca con el plano, bastará con ver que no sean paralelos.
El punto de intersección (en particular, el parámetro $t$ del rayo) se puede
despejar de la ecuación del plano:

\begin{align*}
    ((P + tD) - O) \cdot N &= 0 \\
    (tD \cdot N) + (P - O) \cdot N &= 0 \\
    t(D \cdot N) &= (O - P) \cdot N \\
    t &= \frac{(O - P) \cdot N}{D \cdot N} \\
\end{align*}

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{PlaneHit}{$Plane, Ray, t_{min}, t_{max}$}{$\rightarrow (hit, record)$}
    \State $O, N \gets Plane$ \Comment{Descomponemos en origen y normal}
    \State $P, D \gets Ray$ \Comment{Descomponemos en origen y dirección}
    \If {$N \perp D$} \Comment{Rayo y plano son paralelos}
        \State \Return (False, NIL)
    \EndIf
    \State $t \gets ((O - P) \cdot N)/(D \cdot N)$

    \If {$\lnot (t_{min} \le t \le t_{max})$} \Comment{Punto fuera del rango permitido}
        \State \Return (False, NIL)
    \EndIf

    \State $record \gets$ ($t$, $N$, \dots) \Comment{Datos de la intersección}
    \State \Return (True, $record$)
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{hit} para planos}
\label{alg:plane-hit}
\end{algorithm}

El algoritmo \ref{alg:plane-hit} encapsula estas reglas. Devuelve un par $(hit,
record)$ donde $hit$ es un booleano que indica si hubo intersección, y $record$
contiene los datos de la misma (como la ``distancia'' desde el origen del rayo
$t$, o la normal del plano de intersección $N$), o \texttt{NIL} si no hubo
intersección.

\subsubsection{Esferas}

Para representar una esfera usamos un punto $C$ para representar el centro, y un
radio $r$. La ecuación de los puntos $Q=(x, y, z)$ de la superficie de una
esfera esta dada por:

\begin{align*}
    (x - C_x)^2 + (y - C_y)^2 + (z - C_z)^2 &= r^2 \\
    (Q - C) \cdot (Q - C) = r^2
\end{align*}

Si $Q = R(t) = P + tD$, podemos reemplazarlo en la ecuación y obtener una
ecuación cuadrática en $t$.

\begin{align*}
    (P + tD - C) \cdot (P + tD - C) &= r^2 \\
    t^2 D \cdot D + 2tD \cdot (P - C) + (P - C) \cdot (P - C) - r^2 &= 0
    \label{eq:cuad-esfera}
\end{align*}

Esta función puede tener 0, 1 o 2 raíces, dependiendo de si el rayo intersecta o
no con la esfera, y en cuantos puntos lo hace. Si la función no tiene raíces, no
existe $t$ que satisfaga la ecuación de la esfera, y por lo tanto, no hay
intersección. Si la función tiene 1 raíz, el rayo intersecta a la esfera en
\textbf{un} único punto, y es tangente a la superficie de la misma. Por otro
lado, si la función tiene 2 raíces, el rayo atraviesa a esfera y la intersecta
en 2 puntos, uno de entrada y uno de salida.

Para decidir si el rayo intersecta o no, podemos calcular el discriminante y ver
si es negativo (no intersecta) o no.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{SphereHit}{$Sphere, Ray, t_{min}, t_{max}$}{$\rightarrow (hit, record)$}
    \State $C, r \gets Sphere$ \Comment{Descomponemos en centro y radio}
    \State $P, D \gets Ray$ \Comment{Descomponemos en origen y dirección}
    \State $a \gets D \cdot D$
    \State $b \gets 2D \cdot (P - C)$
    \State $c \gets (P - C) \cdot (P - C) - r^2$
    \State $disc \gets b^2 - 4ac$

    \If {$disc < 0$}
        \State \Return (False, \texttt{NIL})
    \EndIf

    \State $t \gets (-b - \sqrt{disc} / 2a)$
    \If {$t < t_{min} \lor t_{max} < t$}
        \State $t \gets (-b + \sqrt{disc} / 2a)$
        \If {$t < t_{min} \lor t_{max} < t$}
            \State \Return (False, \texttt{NIL})
        \EndIf
    \EndIf

    \State $N \gets P + tD - C$ \Comment{Normal al plano de la intersección}
    \State $record \gets$ ($t$, $N$, \dots) \Comment{Datos de la intersección}
    \State \Return (True, $record$)
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{hit} para esferas}
\label{alg:sphere-hit}
\end{algorithm}

\subsubsection{Cubos}

La forma más directa de implementar cubos es utilizando planos para representar
cada cara. Para simplificar la implementación, solo representaremos cubos
alineados a los ejes de coordenadas del espacio, de forma tal que basta con dar
las coordenadas de 2 vertices opuestos para determinar su posición y tamaño.

Sobre cada uno de estos vertices ubicamos 3 planos con normales sobre cada eje,
con dirección opuesta al otro vértice, de forma que los 6 planos encapsulen el
volumen del cubo.

% TODO: incluir imagen de lo descripto anteriormente

Debido a que los planos son infinitos y estan sobre cada eje del espacio,
cualquier rayo intersecará con al menos 2 planos del cubo. Para decidir si
alguna de estas intersecciones corresponde a alguna cara del cubo, tenemos que
verificar que el punto se encuentre dentro del volumen del mismo. Para esto
usamos las coordenadas de los 2 vertices que definen al cubo: cada coordenada
del punto de intersección debe estar entre las coordenadas correspondientes de
los vertices.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{CubeHit}{$Cube, Ray, t_{min}, t_{max}$}{$\rightarrow (hit, record)$}
    \State $vmin \gets Cube.vmin$ \Comment{Obtenemos los vertices del cubo}
    \State $vmax \gets Cube.vmax$
    \State $faces \gets Cube.faces$

    \State $hitAnyFace \gets$ False
    \State $closestSoFar \gets \infty$
    \State $cubeRecord \gets$ NIL

    \For {$face \in faces$} \Comment{Cada cara es un plano}
        \State {$(faceHit, faceRecord) \gets$ PlaneHit($face, Ray, t_{min}, closestSoFar$)}
        \State {$insideBox \gets$ puntoEntreVertices($faceRecord.p, vmin, vmax$)}

        \If {$faceHit \land insideBox$}
            \State {$hitAnyFace \gets$ True}
            \State {$closestSoFar \gets faceRecord.t$}
            \State {$cubeRecord \gets faceRecord$}
        \EndIf
    \EndFor

    \State \Return ($hitAnyFace, cubeRecord$)
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{hit} para cubos}
\label{alg:box-hit}
\end{algorithm}

En el algoritmo \ref{alg:box-hit}, $hitAnyFace$ es \texttt{True} si y solo si el
rayo $Ray$ interseca a alguna cara del cubo y lo hace dentro de las coordenadas
definidas por los limites del mismo ($vmin$ y $vmax$). En ese caso, se setea
$closestSoFar$ para ignorar las proximas intersecciones que podrían quedar detrás
de la más cercana a la camara, y se guarda el registro de la interseccion en
$cubeRecord$.

\subsubsection{Triangulos}

Nuevamente podemos utilizar lo que conocemos sobre planos para definir un
triangulo. Al definir el triangulo con 3 puntos, definimos tambin el plano sobre
el que se encuentra. Para acomodarnos a la representacion que adoptamos para los
planos, podemos usar alguno de los vertices como origen, y calcular la normal
como el producto vectorial de los vectores que inciden sobre el origen.

% TODO: incluir grafico que ilustre esto.

Al igual que hicimos con el cubo, primero calcularemos el punto de interseccin
entre el rayo y el plano, y luego verificaremos que el punto se encuentre entre
los vertices del triangulo para determinar si el rayo intersecta o no con el
mismo. Para verificar esto, tenemos que definir una convención para indicar que
cara del triangulo es la ``visible'' (es decir, en que sentido apunta la normal
del plano). Sean $P_1$, $P_2$ y $P_3$ los vertices del triangulo, entonces llamamos
cara ``visible'' a la cara en la que estos vértices aparecen en sentido anti-horario.

Si sabemos que los vertices aparecen en cierto orden, detectar un punto dentro de
la superficie del triangulo consiste en verificar que el punto se encuentra ``dentro''
para cada borde. Es decir, sea $P$ un punto en el plano del triangulo, si:

\begin{itemize}
    \item $(P_2 - P_1) \times (P - P_1)$ apunta en el sentido de la normal,
    \item $(P_3 - P_2) \times (P - P_2)$ apunta en el sentido de la normal, y
    \item $(P_1 - P_3) \times (P - P_3)$ apunta en el sentido de la normal
\end{itemize}

significa que $P$ esta ``dentro'' del triangulo para cada borde.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{TriangleHit}{$Triangle, Ray, t_{min}, t_{max}$}{$\rightarrow (hit, record)$}
    \State $P_1, P_2, P_3 \gets Triangle$ \Comment{Obtenemos los vertices del triangulo}
    \State $normal \gets (P_2 - P_1) \times (P_3 - P_1)$
    
    \If {$normal \perp Ray.dir$}
        \State \Return (False, NIL) \Comment{Si el rayo es paralelo al plano, no hay hit}
    \EndIf

    \State $t \gets ((P_1 - Ray.origin) \cdot normal) / (Ray.dir \cdot normal)$
    \If {$\lnot (t_{min} \le t \le t_{max})$} 
        \State \Return (False, NIL)
    \EndIf

    \State $P \gets Ray.at(t)$ \Comment{Punto de intersección}
    \State $dentroBorde1 \gets normal \cdot ((P_2 - P_1) \times (P - P_1)) > 0$
    \State $dentroBorde2 \gets normal \cdot ((P_3 - P_2) \times (P - P_2)) > 0$
    \State $dentroBorde3 \gets normal \cdot ((P_1 - P_3) \times (P - P_3)) > 0$


    \If {$dentroBorde1 \land dentroBorde2 \land dentroBorde3$}
        \State $record \gets (t, p, normal, \dots)$
        \State \Return (True, $record$)
    \EndIf

    \State \Return (False, NIL)
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{hit} para triangulos}
\label{alg:triangle-hit}
\end{algorithm}

Se puede comprobar que el sentido de dos vectores es el mismo al ver el signo de
su producto interno, ya que $A \cdot B = \vert A \vert \vert B \vert
\cos{\theta}$, donde $\theta$ es el angulo entre $A$ y $B$. En este caso,
$\theta$ o bien es 0 y $\cos{0} = 1$, o bien es 180 y $\cos{180}=-1$.

\subsection{Materiales}

Los materiales están asociados a cada objeto y se encargan de darle color a una
escena. Cada material puede emitir / atenuar luz y reflejar / refractar
rayos. En este trabajo, se implementaron 4 tipos:

\begin{itemize}
    \item Luz Difusa
    \item Lambertiano
    \item Metal
    \item Dieléctrico
\end{itemize}

Cada material implementa 2 métodos: \texttt{Scatter} (atenuar / dispersar) y
\texttt{Emit} (emitir):

\begin{itemize}
    \item \texttt{Scatter} recibe 3 parámetros: el material ($M$) sobre el que
        incide el rayo, el rayo en cuestión ($R_{in}$), y la metadata de la
        colisión ($rec$) que se dio sobre el objeto al que esta asociado el
        material. Devuelve 3 valores: \textit{did\_scatter} que indica si el
        material puede dispersar rayos en el punto de intersección,
        \textit{R\_{out}} el rayo dispersado en caso de que el anterior sea
        \texttt{TRUE}, y $A$ la atenuación del color que produce el material.
    \item \texttt{Emit} solamente recibe el material $M$ y retorna el color que
        emite el mismo.
\end{itemize}

Estos métodos serán llamados por cada rayo que se genere desde la cámara.
\texttt{Scatter} se encarga de dirigir cada rayo en cada colisión, hasta llegar
a un material que no disperse más (\textit{did\_scatter} en \texttt{False}), o
hasta que se supere el \textit{max depth} de la imagen.

Por la naturaleza de los materiales que se eligieron, Luz Difusa solamente emite
luz, y el resto solamente atenúa luz  y refleja / refracta los rayos que
reciben. A continuación describiremos como se implementa estos métodos, y en los
casos en los que se omita alguno se toma por defecto que \texttt{Emit} devuelve
un color negro \texttt{\#000000} (es decir, no emite luz), y que
\texttt{Scatter} devuelve \texttt{(False, NIL, NIL)} (es decir, ni atenúa ni
dispersa).

\subsubsection{Luz Difusa}

Para crear este material solo necesitamos un color $A$, que será el valor que se
devuelva al llamar al método \texttt{Emit} sobre el mismo.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{DiffuseLightEmit}{$Light$}{$\rightarrow A$}
    \State \Return $Light.A$
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{Emit} para Luz Difusa}
\label{alg:diffuse-light-emit}
\end{algorithm}

\subsubsection{Lambertiano}

Un material difuso o lambertiano se caracteriza por verse uniformemente
iluminado de todas las direcciones. Si bien posee un color propio $A$, también
toma parte de los colores de su entorno para formar el color final de la imagen.

\begin{algorithm}[H]
\begin{algorithmic}[1]
    \Function{LambertianScatter}{$Lambertian, r_{in}, rec$}{$\rightarrow
    (did\_scatter, A, R_{out})$}

    \State $scatterdir \gets rec.normal +$ (vector random en esfera unitaria)

    \If {$scatterdir \approx \vec{0}$}
        \State $scatterdir \gets rec.normal$
    \EndIf

    \State $r_{out} \gets \left \langle rec.p, scatterdir \right \rangle$
    \State \Return (True, $Lambertian.A$, $r_{out}$)
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{Scatter} para material Lambertiano}
\label{alg:lambertian-scatter}
\end{algorithm}

Para simular el aporte uniforme de todo el entorno, en el algoritmo
\ref{alg:lambertian-scatter} tomamos como referencia la normal al plano de
intersección $rec.normal$ y le sumamos un vector random $v$ en la esfera
unitaria (es decir, $v \in \mathbb{R}^3, \vert v \vert = 1$). Puede ocurrir que
$rec.normal \approx -v$, lo cual resulte en un $scatterdir \approx 0$. En ese
caso, simplemente tomamos $scatterdir = rec.normal$.

\subsubsection{Metal}

Por otro lado, los materiales metálicos están caracterizados por reflejar muy
bien los rayos, dependiendo de que tan ``pulido'' esté el mismo. Vamos a
parametrizar un material metálico nuevamente con un color $A$, y con un valor de
\textit{fuzziness} $f \in [0, 1]$. Si $f=0$, los rayos se reflejan perfectamente
sobre la superficie, y para $f>0$, se le suma algo de aleatoriedad al rayo de
salida, cuyo aporte incrementa con $f$.

\begin{algorithm}[H]
\begin{algorithmic}[1]
    \Function{MetalScatter}{$Metal, r_{in}, rec$}{$\rightarrow
    (did\_scatter, A, R_{out})$}

    \State $d \gets r_{in}.dir$
    \State $n \gets rec.normal$
    \State $reflected \gets d - 2 (d \cdot n) n $

    \If {$reflected \cdot n \le 0$} 
        \State \Return (False, NIL, NIL)
    \EndIf

    \State $scatterdir \gets reflected + Metal.f \times$ (vector random en esfera
    unitaria)

    \State $r_{out} \gets \left \langle rec.p, scatterdir \right \rangle$
    \State \Return (True, $Metal.A$, $r_{out}$)
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{Scatter} para material metálico}
\label{alg:metal-scatter}
\end{algorithm}

Como vemos en el algoritmo \ref{alg:metal-scatter}, la aleatoriedad la provee un
vector random en la esfera unitaria. En caso de que el rayo reflejado no se
encuentre del lado de la cara de la superficie ($reflected \cdot n \le 0$), el
material no dispersa el rayo y devuelve \texttt{(False, NIL, NIL)}.

\subsubsection{Dieléctrico}

Los materiales dielectricos son aquellos que al recibir rayos de luz, son
capaces de separarlos en un rayo que se refleja, y otro que se refracta. Si bien
nuestra representación solo permite un rayo de salida, simularemos este
comportamiento reflejando y refractando rayos en cada punto de un objeto de
manera aleatoria.

\begin{figure}
    \centering
    \includegraphics[width=.7\textwidth]{imgs/refraction.jpg}
    \caption{Ley de Snell}
    \label{fig:snell-law}
\end{figure}

Ya vimos como calcular el rayo reflejado, así que veremos como calcular el
refractado. Así como un rayo se refleja al entrar en contacto con una
superficie, la refracción se da en la frontera entre 2 materiales con indices de
refracción $\eta$ y $\eta'$ (ver figura \ref{fig:snell-law}). Si el rayo viaja
por un material ($\eta$), y llega a la frontera con otro material ($\eta'$), el
angulo de ``entrada'' en el primer material $\theta$ y el angulo de ``salida'' en el
segundo material $\theta'$ están relacionados por la ley de Snell:

\[
    \eta \sin \theta = \eta' \sin \theta'
\]

Suponiendo que conocemos $\eta$ y $\eta'$ (uno es el índice del material, y el
otro podemos asumir que es el índice del aire), y como además conocemos $\theta$
(el angulo con el que un rayo incide sobre una superficie respecto de la
normal), podemos calcular $\sin \theta'$ despejando de la ecuación:

\[
    \sin \theta' = \frac{\eta}{\eta'} \sin \theta
\]

El rayo refractado que se encuentra del otro lado de la frontera es $R'$, y se
puede descomponer en $R'_{\perp}$ perpendicular a la normal, y
$R_{\parallel}$ paralela a la normal: $R' = R'_{\perp} + R'_{\parallel}$.

Se puede probar que cada componente se calcula como:

\begin{align*}
    R'_{\perp} &= \frac{\eta}{\eta'}(R + (-R \cdot n) n) \\
    R'_{\parallel} &= - \sqrt{1 - \vert R'_{\perp} \vert^2} n
\end{align*}

Y finalmente, el rayo refractado se puede calcular con el algoritmo
\ref{alg:refract}.

\begin{algorithm}[H]
\begin{algorithmic}[1]
    \Function{Refract}{$R$, $n$, $i$}{ $\rightarrow R'$}

    \State $cos_{\theta} = \min\{-R \cdot n, 1.0\}$
    \State $R'_{\perp} = i (R + cos_{\theta} n)$
    \State $R'_{\parallel} = - \sqrt{\vert 1 - \Vert R'_{\perp} \Vert ^ 2 \vert} n$

    \State \Return $R'_{\perp} + R'_{\parallel}$
\EndFunction
\end{algorithmic}
\caption{Algoritmo para refractar un rayo $R$ sobre una superficie con normal
$n$ y relación de indices de refracción $i = \eta / \eta'$}
\label{alg:refract}
\end{algorithm}

Si usáramos éste algoritmo para definir \texttt{DielectricScatter} y calcular el
nuevo rayo, obtendríamos imágenes poco realistas, ya que los materiales
dieléctricos no siempre refractan los rayos. Por ejemplo, si el radio entre los
indices de refracción es mayor a 1, la refracción no es posible:

\[
    \sin \theta' = \frac{\eta}{\eta'} \cdot \sin \theta = i \cdot \sin \theta
\]

Como $\sin \theta' \in [0, 1]$, si $i \cdot \sin \theta > 1$, entonces no existe valor
de $\theta'$ que satisfaga la ecuación.

Además, los materiales dieléctricos son capaces de reflejar dependiendo del
ángulo sobre el que incide el rayo. Si bien existe una ecuación para determinar
ésto, podemos usar la aproximación de Schlick \cite{schlicksapprox} como una
alternativa simple y que para nuestro caso de uso alcanza. La misma se basa en
el uso de una propiedad llamada \textit{reflectance} que se calcula usando el
coseno del ángulo de incidencia y la relación entre los índices de refracción.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{Reflectance}{$\cos_{\theta}$, $i$}{ $\rightarrow R'$}
    \State $r \gets \frac{1 - i}{1 + i}$
    \State \Return $r^2 + (1-r^2) (1 - \cos_{\theta})^5$
\EndFunction
\end{algorithmic}
\caption{Calculo de la \textit{reflectance} de un rayo que incide con un ángulo
cuyo coseno es $\cos_{\theta}$, y con un radio de refracción $i = \eta / \eta'$}
\label{alg:reflectance}
\end{algorithm}

El algoritmo \ref{alg:reflectance} calcula este valor. Lo que luego se pide en
la aproximación es que sea mayor que un valor aleatorio entre $[0, 1]$.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\Function{DielectricScatter}{$Dielectric, r_{in}, rec$}{$\rightarrow
    (did\_scatter, A, R_{out})$}
    \State $r \gets Dielectric.ir$
    \If {hit in $rec$ was front face}
        \State $r \gets Dielectric.ir^{-1}$
    \EndIf
    \State $u \gets normalized(r_{\text{in}}.direction)$
    \State $\cos_{\theta} \gets \min(1, -u \cdot rec.normal)$
    \State $\sin_{\theta} \gets \sqrt{1 - \cos_{\theta}^2}$

    \If {$r \sin_{\theta} > 1$ \textbf{or} reflectance($\cos_{\theta}, r$) $>$ (random in
    [0, 1])}
        \State $dir \gets$ reflect($u$, $rec.normal$)
    \Else
        \State $dir \gets$ refract($u, rec.normal, r$)
    \EndIf

    \State \Return (True, $Dielectric.albedo$, $\langle rec.point, dir \rangle$)
\EndFunction
\Function{reflect}{$v$, $n$}{$\rightarrow v'$}
    \State \Return $v - 2 (v \cdot n) n$
\EndFunction
\end{algorithmic}
\caption{Algoritmo \textit{Scatter} para material dieléctrico}
\label{alg:dielectric-scatter}
\end{algorithm}
